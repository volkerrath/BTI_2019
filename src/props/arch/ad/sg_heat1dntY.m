%
%                             DISCLAIMER
%
%
% This file was generated by:
% ADiMat Version 0.4-r9 (beta, lcse, gcse(?), fwdmd, 2fwdmd, opt_ls, constfold, narg, vararg(?), Jun 21 2006) arch: i686-pc-linux-gnu
% compiled Jun 21 2006 with gcc 3.4.4 20050721 (Red Hat 3.4.4-2).
% Copyright 2001- 2004 Andre Vehreschild, Institute for
% Scientific Computing, Aachen University, D-52056 Aachen, Germany.
% http://www.sc.rwth-aachen.de/vehreschild/adimat/
% This file was augmented on Thu Apr 10 14:40:11 2008
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% FUNCMODE -- Inputfile is a function (This flag can not be set explicitly).
% AD_IVARS= GST
% AD_DVARS= T

function [g_T, T, z, t]= g_heat1dnt(kl, kAl, kBl, hl, rcml, porl, qb, dz, ip, dt, it, g_GST, GST, T0, theta, maxiter, tol, freeze, out)
   narginmapper_00000= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 12, 13, 14, 15, 16, 17, 18];
   %adimat-directive consumed: %ADiMat BMFUNC $$=spdiags($1, $#) DIFFTO spdiags( $@1, $#)
   %
   % HEAT1DNTP  solves nonlinear time-dependent heat equation
   % for general 1-D grid with permafrost.
   %
   % T = heat1dnt(par,nu,ip,dz,dt,T0,GST,methods) calculates
   % numerically (FD) temperatures for a given set of timesteps,
   % given a model for thermal conductivity, heat production and rho*c.
   % transient heat conduction with time-dependent source term is assumed.
   % thermal conductivity and heat capacity are assumed as nonlinear
   % functions of temperature;
   % Input :
   % k (1:nu)              = lambda matrix
   % kA, kB(1:nu)	 	= thermal conductivity coefficient A and B
   % hl(1:nu)		= volumetric heat production matrix
   % cml (1:nu)		= heat capacity c_p matrix
   % rhoml 		= density c_p matrix
   % porl			= porosity
   % qb			= basal heat flow
   % ip (1:nc)     	= pointer to assign parameters to cells
   %                 	   	(nc gridsize in cells)
   % dz(1:nc)      	= cell size (m)
   % dt(1:nt-1)    	= time step (s)
   % T0(1:nc+1)        	= initial temperatures
   % GST(1:nt+1)        	= time-dependent boundary temperatures
   %                     		at the top (e.g., paleoclimate)
   % theta(1:nt-1)      	= methods(1:nt) is time stepping control parameter,
   %                      		.5 =Crank-Nicholson, 1=Bacward Euler
   % maxiter,tol         	= maximal number of nonlinear Picard iterations and
   %                       	tolerance (max deviation from last iteration)
   %
   % Output:
   % T(1:nc+1,1:nt )  = temperatures at given time steps
   %
   %
   % V. R., July 20, 2005
   rref= 2650; 
   mean= 'g'; relax= 1.; 
   Lh= 333600; Tf= 0; w= 1.; 
   
   
   if narginmapper_00000(nargin)< 17, freeze= 'yes'; end
   if narginmapper_00000(nargin)< 18, out= 'no'; end
   
   
   [n1, n2]= size(ip); if n1== 1, tmp_heat1dnt_00041= ip' ; % Update detected: ip= some_expression(ip,...)
      ip= tmp_heat1dnt_00041;
   end
   [n1, n2]= size(dz); if n1== 1, tmp_heat1dnt_00042= dz' ; % Update detected: dz= some_expression(dz,...)
      dz= tmp_heat1dnt_00042;
   end
   [n1, n2]= size(dt); if n1== 1, tmp_heat1dnt_00043= dt' ; % Update detected: dt= some_expression(dt,...)
      dt= tmp_heat1dnt_00043;
   end
   
   nt= length(dt)+ 1; 
   nc= length(ip); nz= nc+ 1; 
   
   k= kl(ip(1: nc)); % thermal conductivity
   [n1, n2]= size(k); if n1== 1, tmp_heat1dnt_00044= k' ; % Update detected: k= some_expression(k,...)
      k= tmp_heat1dnt_00044;
   end
   kA= kAl(ip(1: nc)); % thermal conductivity coefficient A
   [n1, n2]= size(kA); if n1== 1, tmp_heat1dnt_00045= kA' ; % Update detected: kA= some_expression(kA,...)
      kA= tmp_heat1dnt_00045;
   end
   kB= kBl(ip(1: nc)); % thermal conductivity coefficient B
   [n1, n2]= size(kB); if n1== 1, tmp_heat1dnt_00046= kB' ; % Update detected: kB= some_expression(kB,...)
      kB= tmp_heat1dnt_00046;
   end
   h= hl(ip(1: nc)); % heat production
   [n1, n2]= size(h); if n1== 1, tmp_heat1dnt_00047= h' ; % Update detected: h= some_expression(h,...)
      h= tmp_heat1dnt_00047;
   end
   rhocm= rcml(ip(1: nc)); % density
   [n1, n2]= size(rhocm); if n1== 1, tmp_heat1dnt_00048= rhocm' ; % Update detected: rhocm= some_expression(rhocm,...)
      rhocm= tmp_heat1dnt_00048;
   end
   por= porl(ip(1: nc)); % pcorosity
   [n1, n2]= size(por); if n1== 1, tmp_heat1dnt_00049= por' ; % Update detected: por= some_expression(por,...)
      por= tmp_heat1dnt_00049;
   end
   %
   one= ones(size(ip)); 
   zero= zeros(size(ip)); 
   %INITIAL VALUES
   
   % initialize time, depth and pressure
   t= [0;
      cumsum(dt)]; 
   z= [0;
      cumsum(dz)]; zc= 0.5* (z(1: nz- 1)+ z(2: nz)); Pc= 998.* 9.81* zc; 
   
   g_Pc= zeros(size(Pc));
   Tlast= T0; g_Tlast= zeros(size(Tlast));
   Titer= T0; g_Titer= zeros(size(Titer));
   g_Tlast(1)= g_GST(1);
   Tlast(1)= GST(1); g_Titer(1)= g_GST(1);
   Titer(1)= GST(1); 
   
   dc= 0.5* (dz(2: nc)+ dz(1: nc- 1)); 
   
   I= speye(nz, nz); 
   
   % START TIME STEPPING
   for i= 1: nt- 1
      
      %   start NONLINEAR ITERATION
      
      for iter= 1: maxiter%        build SYSTEM MATRIX
         %        initialize diagonals
         a(1: nz)= 0.; g_a(1: nz)= zeros(size(a(1: nz)));
         b(1: nz)= 0.; g_b(1: nz)= zeros(size(b(1: nz)));
         c(1: nz)= 0.; 
         %        define  coefficienGST for interior poinGST
         
         g_c(1: nz)= zeros(size(c(1: nz)));
         if iter== 1
            [g_tmp_n2c_00000, tmp_n2c_00000]= g_n2c(g_Tlast, Tlast, dz);
            g_Tc= (g_tmp_n2c_00000);
            Tc= (tmp_n2c_00000); 
            clear tmp_n2c_00000 g_tmp_n2c_00000 ;
         else 
            g_tmp_heat1dnt_00000= relax* g_Titer;
            tmp_heat1dnt_00000= relax* Titer;
            g_tmp_heat1dnt_00001= (1- relax)* g_Tlast;
            tmp_heat1dnt_00001= (1- relax)* Tlast;
            g_Titer= g_tmp_heat1dnt_00000+ g_tmp_heat1dnt_00001;
            Titer= tmp_heat1dnt_00000+ tmp_heat1dnt_00001; 
            clear tmp_heat1dnt_00000 tmp_heat1dnt_00001 g_tmp_heat1dnt_00000 g_tmp_heat1dnt_00001 ;
            [g_Tc, Tc]= g_n2c(g_Titer, Titer, dz); 
            
         end
         
         [g_tmp_rhofT_00000, tmp_rhofT_00000]= g_rhofT(g_Tc, Tc, g_Pc, Pc);
         g_tmp_heat1dnt_00002= 9.81* g_tmp_rhofT_00000;
         tmp_heat1dnt_00002= 9.81* tmp_rhofT_00000;
         g_Pc= g_tmp_heat1dnt_00002.* zc;
         Pc= tmp_heat1dnt_00002.* zc; 
         clear tmp_rhofT_00000 tmp_heat1dnt_00002 g_tmp_rhofT_00000 g_tmp_heat1dnt_00002 ;
         [g_tmp_rhoiT_00000, tmp_rhoiT_00000]= g_rhoiT(g_Tc, Tc);
         [g_tmp_cpiT_00000, tmp_cpiT_00000]= g_cpiT(g_Tc, Tc);
         g_rci= ls_prod(g_tmp_rhoiT_00000, tmp_rhoiT_00000, g_tmp_cpiT_00000, tmp_cpiT_00000);
         rci= tmp_rhoiT_00000.* tmp_cpiT_00000; 
         clear tmp_rhoiT_00000 tmp_cpiT_00000 g_tmp_rhoiT_00000 g_tmp_cpiT_00000 ;
         [g_ki, ki]= g_kiT(g_Tc, Tc); 
         [g_rhof, rhof]= g_rhofT(g_Tc, Tc, g_Pc, Pc); 
         [g_tmp_cpfT_00000, tmp_cpfT_00000]= g_cpfT(g_Tc, Tc, g_Pc, Pc);
         g_rcf= ls_prod(g_rhof, rhof, g_tmp_cpfT_00000, tmp_cpfT_00000);
         rcf= rhof.* tmp_cpfT_00000; 
         clear tmp_cpfT_00000 g_tmp_cpfT_00000 ;
         [g_kf, kf]= g_kfT(g_Tc, Tc); 
         [g_tmp_cpmT_00000, tmp_cpmT_00000]= g_cpmT(zeros(size(rhocm)),rhocm/ rref, g_Tc, Tc);
         g_rcm= g_tmp_cpmT_00000* rref;
         rcm= tmp_cpmT_00000* rref; 
         clear tmp_cpmT_00000 g_tmp_cpmT_00000 ;
         [g_km, km]= g_kmT(k, g_Tc, Tc, kA, kB); 
         
         %  permafrost
         if strcmpi(freeze, 'yes')== 1, 
            [g_gf, gf, g_dgf, dgf]= g_ftheta(g_Tc, Tc, Tf, w); 
            %            gf=gf';dgf=dgf';
         else 
            gf= one; g_gf= zeros(size(gf));
            dgf= zero; 
            g_dgf= zeros(size(dgf));
         end
         
         porm= one- por; 
         g_porf= por.* g_gf;
         porf= por.* gf; 
         g_pori= (-g_porf);
         pori= por- porf; 
         
         switch lower(mean)
            case {'a', 'ari', 'arithmetic'}
               g_tmp_heat1dnt_00003= ls_prod(g_porf, porf, g_kf, kf);
               tmp_heat1dnt_00003= porf.* kf;
               g_tmp_heat1dnt_00004= ls_prod(g_pori, pori, g_ki, ki);
               tmp_heat1dnt_00004= pori.* ki;
               g_tmp_heat1dnt_00005= porm.* g_km;
               tmp_heat1dnt_00005= porm.* km;
               g_keff= g_tmp_heat1dnt_00003+ g_tmp_heat1dnt_00004+ g_tmp_heat1dnt_00005;
               keff= tmp_heat1dnt_00003+ tmp_heat1dnt_00004+ tmp_heat1dnt_00005; 
               clear tmp_heat1dnt_00003 tmp_heat1dnt_00004 tmp_heat1dnt_00005 g_tmp_heat1dnt_00003 g_tmp_heat1dnt_00004 g_tmp_heat1dnt_00005 ;
            case {'g', 'geo', 'geometric'}
               g_tmp_log_00000= ((g_kf)./ (kf));
               tmp_log_00000= log(kf);
               g_tmp_heat1dnt_00006= ls_prod(g_tmp_log_00000, tmp_log_00000, g_porf, porf);
               tmp_heat1dnt_00006= tmp_log_00000.* porf;
               g_tmp_log_00001= ((g_ki)./ (ki));
               tmp_log_00001= log(ki);
               g_tmp_heat1dnt_00007= ls_prod(g_tmp_log_00001, tmp_log_00001, g_pori, pori);
               tmp_heat1dnt_00007= tmp_log_00001.* pori;
               g_tmp_log_00002= ((g_km)./ (km));
               tmp_log_00002= log(km);
               g_tmp_heat1dnt_00008= g_tmp_log_00002.* porm;
               tmp_heat1dnt_00008= tmp_log_00002.* porm;
               g_tmp_heat1dnt_00009= g_tmp_heat1dnt_00006+ g_tmp_heat1dnt_00007+ g_tmp_heat1dnt_00008;
               tmp_heat1dnt_00009= tmp_heat1dnt_00006+ tmp_heat1dnt_00007+ tmp_heat1dnt_00008;
               g_keff= ((g_tmp_heat1dnt_00009).* exp(tmp_heat1dnt_00009));
               keff= exp(tmp_heat1dnt_00009); 
               clear tmp_log_00000 tmp_heat1dnt_00006 tmp_log_00001 tmp_heat1dnt_00007 tmp_log_00002 tmp_heat1dnt_00008 tmp_heat1dnt_00009 g_tmp_log_00000 g_tmp_heat1dnt_00006 g_tmp_log_00001 g_tmp_heat1dnt_00007 g_tmp_log_00002 g_tmp_heat1dnt_00008 g_tmp_heat1dnt_00009 ;
            case {'h', 'har', 'harmonic'}
               g_tmp_heat1dnt_00010= ls_quot(g_porf, porf, g_kf, kf);
               tmp_heat1dnt_00010= porf./ kf;
               g_tmp_heat1dnt_00011= ls_quot(g_pori, pori, g_ki, ki);
               tmp_heat1dnt_00011= pori./ ki;
               g_tmp_heat1dnt_00012= (-porm.* g_km)./ km.^ 2;
               tmp_heat1dnt_00012= porm./ km;
               g_tmp_heat1dnt_00013= g_tmp_heat1dnt_00010+ g_tmp_heat1dnt_00011+ g_tmp_heat1dnt_00012;
               tmp_heat1dnt_00013= tmp_heat1dnt_00010+ tmp_heat1dnt_00011+ tmp_heat1dnt_00012;
               g_keff= (-(g_tmp_heat1dnt_00013))./ (tmp_heat1dnt_00013).^ 2;
               keff= 1./ (tmp_heat1dnt_00013); 
               clear tmp_heat1dnt_00010 tmp_heat1dnt_00011 tmp_heat1dnt_00012 tmp_heat1dnt_00013 g_tmp_heat1dnt_00010 g_tmp_heat1dnt_00011 g_tmp_heat1dnt_00012 g_tmp_heat1dnt_00013 ;
            case {'s', 'sqr', 'sqrmean'}
               g_tmp_sqrt_00000= ((g_kf)./ (2.* sqrt(kf)));
               tmp_sqrt_00000= sqrt(kf);
               g_tmp_heat1dnt_00014= ls_prod(g_porf, porf, g_tmp_sqrt_00000, tmp_sqrt_00000);
               tmp_heat1dnt_00014= porf.* tmp_sqrt_00000;
               g_tmp_sqrt_00001= ((g_ki)./ (2.* sqrt(ki)));
               tmp_sqrt_00001= sqrt(ki);
               g_tmp_heat1dnt_00015= ls_prod(g_pori, pori, g_tmp_sqrt_00001, tmp_sqrt_00001);
               tmp_heat1dnt_00015= pori.* tmp_sqrt_00001;
               g_tmp_sqrt_00002= ((g_km)./ (2.* sqrt(km)));
               tmp_sqrt_00002= sqrt(km);
               g_tmp_heat1dnt_00016= porm.* g_tmp_sqrt_00002;
               tmp_heat1dnt_00016= porm.* tmp_sqrt_00002;
               g_tmp_heat1dnt_00017= g_tmp_heat1dnt_00014+ g_tmp_heat1dnt_00015+ g_tmp_heat1dnt_00016;
               tmp_heat1dnt_00017= tmp_heat1dnt_00014+ tmp_heat1dnt_00015+ tmp_heat1dnt_00016;
               g_keff= 2.* (tmp_heat1dnt_00017).* (g_tmp_heat1dnt_00017);
               keff= (tmp_heat1dnt_00017).^ 2; 
               clear tmp_sqrt_00000 tmp_heat1dnt_00014 tmp_sqrt_00001 tmp_heat1dnt_00015 tmp_sqrt_00002 tmp_heat1dnt_00016 tmp_heat1dnt_00017 g_tmp_sqrt_00000 g_tmp_heat1dnt_00014 g_tmp_sqrt_00001 g_tmp_heat1dnt_00015 g_tmp_sqrt_00002 g_tmp_heat1dnt_00016 g_tmp_heat1dnt_00017 ;
            otherwise
               tmp_heat1dnt_00018= ['WMEAN: mode set to arithmetic, >', mean, '<  not defined'];
               disp(tmp_heat1dnt_00018)
               clear tmp_heat1dnt_00018 ;
               g_tmp_heat1dnt_00019= ls_prod(g_porf, porf, g_kf, kf);
               tmp_heat1dnt_00019= porf.* kf;
               g_tmp_heat1dnt_00020= ls_prod(g_pori, pori, g_ki, ki);
               tmp_heat1dnt_00020= pori.* ki;
               g_tmp_heat1dnt_00021= porm.* g_km;
               tmp_heat1dnt_00021= porm.* km;
               g_keff= g_tmp_heat1dnt_00019+ g_tmp_heat1dnt_00020+ g_tmp_heat1dnt_00021;
               keff= tmp_heat1dnt_00019+ tmp_heat1dnt_00020+ tmp_heat1dnt_00021; 
               clear tmp_heat1dnt_00019 tmp_heat1dnt_00020 tmp_heat1dnt_00021 g_tmp_heat1dnt_00019 g_tmp_heat1dnt_00020 g_tmp_heat1dnt_00021 ;
         end
         g_tmp_heat1dnt_00022= porm.* g_rcm;
         tmp_heat1dnt_00022= porm.* rcm;
         g_tmp_heat1dnt_00023= ls_prod(g_pori, pori, g_rci, rci);
         tmp_heat1dnt_00023= pori.* rci;
         g_tmp_heat1dnt_00024= ls_prod(g_porf, porf, g_rcf, rcf);
         tmp_heat1dnt_00024= porf.* rcf;
         g_tmp_heat1dnt_00025= (por.* g_rhof.* Lh.* dgf+ por.* rhof.* Lh.* g_dgf);
         tmp_heat1dnt_00025= por.* rhof.* Lh.* dgf;
         g_rceff= g_tmp_heat1dnt_00022+ g_tmp_heat1dnt_00023+ g_tmp_heat1dnt_00024+ g_tmp_heat1dnt_00025;
         rceff= tmp_heat1dnt_00022+ tmp_heat1dnt_00023+ tmp_heat1dnt_00024+ tmp_heat1dnt_00025; 
         
         %         if nargout > 4 , k_eff(:,i)=keff'; end
         %         if nargout > 5 , rc_eff(:,i)=rceff'; end
         %         if nargout > 6 , ipor(:,i)=(pori./por)'; end
         %         if nargout > 7 , lheat(:,i)=(por.*rhof.*Lh.*dgf)'; end
         %         if nargout > 8 , rci(:,i)=(rhoi.*cpi)'; end
         
         
         clear tmp_heat1dnt_00022 tmp_heat1dnt_00023 tmp_heat1dnt_00024 tmp_heat1dnt_00025 g_tmp_heat1dnt_00022 g_tmp_heat1dnt_00023 g_tmp_heat1dnt_00024 g_tmp_heat1dnt_00025 ;
         g_dl= g_keff./ dz;
         dl= keff./ dz; 
         g_tmp_heat1dnt_00026= g_keff* dt(i);
         tmp_heat1dnt_00026= keff* dt(i);
         g_tmp_heat1dnt_00027= g_rceff.* dz.^ 2;
         tmp_heat1dnt_00027= rceff.* dz.^ 2;
         g_tmp_heat1dnt_00028= ls_quot((g_tmp_heat1dnt_00026), (tmp_heat1dnt_00026), (g_tmp_heat1dnt_00027), (tmp_heat1dnt_00027));
         tmp_heat1dnt_00028= (tmp_heat1dnt_00026)./ (tmp_heat1dnt_00027);
         N(i)= max(tmp_heat1dnt_00028); 
         
         %        define matrix coefficienGST for interior poinGST
         clear tmp_heat1dnt_00026 tmp_heat1dnt_00027 tmp_heat1dnt_00028 g_tmp_heat1dnt_00026 g_tmp_heat1dnt_00027 g_tmp_heat1dnt_00028 ;
         g_c(3: nz)= g_dl(2: nc)./ dc;
         c(3: nz)= dl(2: nc)./ dc; % upper
         g_a(1: nz- 2)= g_dl(1: nc- 1)./ dc;
         a(1: nz- 2)= dl(1: nc- 1)./ dc; % lower
         g_tmp_heat1dnt_00029= g_a(1: nz- 2)+ g_c(3: nz);
         tmp_heat1dnt_00029= a(1: nz- 2)+ c(3: nz);
         g_b(2: nz- 1)= -(g_tmp_heat1dnt_00029);
         b(2: nz- 1)= -(tmp_heat1dnt_00029); % center
         %       modify for dirichlet bc at top node
         clear tmp_heat1dnt_00029 g_tmp_heat1dnt_00029 ;
         b(1)= 1.; 
         %       modify for neumann at bottom node
         g_b(1)= zeros(size(b(1)));
         g_acn= g_keff(nc)/ (dz(nc)* dz(nc));
         acn= keff(nc)/ (dz(nc)* dz(nc)); 
         g_a(nz- 1)= 2.* g_acn;
         a(nz- 1)= 2.* acn; 
         g_b(nz)= -g_a(nz- 1);
         b(nz)= -a(nz- 1); 
         %       generate sparse system matrix from diagonals a,b,and c
         g_tmp_heat1dnt_00030= [g_a' , g_b' , g_c' ];
         tmp_heat1dnt_00030= [a' , b' , c' ];
         g_A= spdiags( g_tmp_heat1dnt_00030, -1: 1, nz, nz);
         A= spdiags(tmp_heat1dnt_00030, -1: 1, nz, nz); 
         %       build RIGHT HAND SIDE
         %       nodal heat sources
         clear tmp_heat1dnt_00030 g_tmp_heat1dnt_00030 ;
         [g_qd, qd]= g_c2n(zeros(size(h)),h, dz); 
         [g_rc, rc]= g_c2n(g_rceff, rceff, dz); 
         g_rhs= g_qd' ;
         rhs= qd' ; 
         %       modify for neumann at bottom node
         g_tmp_heat1dnt_00031= 2* g_acn* dz(nc)* qb;
         tmp_heat1dnt_00031= 2* acn* dz(nc)* qb;
         g_tmp_heat1dnt_00032= ls_mquot(g_tmp_heat1dnt_00031, tmp_heat1dnt_00031, g_keff(nc), keff(nc));
         tmp_heat1dnt_00032= tmp_heat1dnt_00031/ keff(nc);
         g_tmp_heat1dnt_00050= g_rhs(nz)+ g_tmp_heat1dnt_00032;
         tmp_heat1dnt_00050= rhs(nz)+ tmp_heat1dnt_00032; 
         
         % Update detected: rhs= some_expression(rhs,...)
         g_rhs(nz)= g_tmp_heat1dnt_00050;
         rhs(nz)= tmp_heat1dnt_00050;
         clear tmp_heat1dnt_00031 tmp_heat1dnt_00032 g_tmp_heat1dnt_00031 g_tmp_heat1dnt_00032 ;
         g_tmp_heat1dnt_00033= (-g_rc' )./ rc' .^ 2;
         tmp_heat1dnt_00033= 1./ rc' ;
         g_F= spdiags( g_tmp_heat1dnt_00033, 0, nz, nz);
         F= spdiags(tmp_heat1dnt_00033, 0, nz, nz); 
         clear tmp_heat1dnt_00033 g_tmp_heat1dnt_00033 ;
         g_tmp_heat1dnt_00051= ls_mprod(g_F, F, g_A, A);
         tmp_heat1dnt_00051= F* A; % Update detected: A= some_expression(A,...)
         g_A= g_tmp_heat1dnt_00051;
         A= tmp_heat1dnt_00051;
         g_tmp_heat1dnt_00052= ls_quot(g_rhs, rhs, g_rc' , rc' );
         tmp_heat1dnt_00052= rhs./ rc' ; 
         % Update detected: rhs= some_expression(rhs,...)
         g_rhs= g_tmp_heat1dnt_00052;
         rhs= tmp_heat1dnt_00052;
         g_tmp_heat1dnt_00034= dt(i)* theta(i)* g_A;
         tmp_heat1dnt_00034= dt(i)* theta(i)* A;
         g_L= (-g_tmp_heat1dnt_00034);
         L= I- tmp_heat1dnt_00034; 
         %       right hand side
         clear tmp_heat1dnt_00034 g_tmp_heat1dnt_00034 ;
         g_tmp_heat1dnt_00035= dt(i)* (1- theta(i))* g_A;
         tmp_heat1dnt_00035= dt(i)* (1- theta(i))* A;
         g_tmp_heat1dnt_00036= ls_mprod((g_tmp_heat1dnt_00035), (I+ tmp_heat1dnt_00035), g_Tlast, Tlast);
         tmp_heat1dnt_00036= (I+ tmp_heat1dnt_00035)* Tlast;
         g_tmp_heat1dnt_00037= dt(i)* g_rhs;
         tmp_heat1dnt_00037= dt(i)* rhs;
         g_r= g_tmp_heat1dnt_00036+ g_tmp_heat1dnt_00037;
         r= tmp_heat1dnt_00036+ tmp_heat1dnt_00037; 
         %       modify for top (dirichlet) bc:
         clear tmp_heat1dnt_00035 tmp_heat1dnt_00036 tmp_heat1dnt_00037 g_tmp_heat1dnt_00035 g_tmp_heat1dnt_00036 g_tmp_heat1dnt_00037 ;
         g_r(1)= g_GST(it(i+ 1));
         r(1)= GST(it(i+ 1)); L(1, 1)= 1.; 
         %       solve by LU
         g_L(1, 1)= zeros(size(L(1, 1)));
         tmp_heat1dnt_00038= L\ r;
         g_tmp_heat1dnt_00038= ls_msolv(g_L, L, g_r, tmp_heat1dnt_00038);
         g_Tnew= (g_tmp_heat1dnt_00038);
         Tnew= (tmp_heat1dnt_00038); 
         
         
         clear tmp_heat1dnt_00038 g_tmp_heat1dnt_00038 ;
         if iter> 1; 
            checktol_old=checktol;
            g_checktol_old=g_checktol;
            
            g_tmp_heat1dnt_00039= g_Tnew- g_Titer;
            tmp_heat1dnt_00039= Tnew- Titer;
            checktol= norm(tmp_heat1dnt_00039, inf); 
            g_checktol=norm(g_tmp_heat1dnt_00039, inf); 
            
            clear tmp_heat1dnt_00039 g_tmp_heat1dnt_00039 ;
            if out> 1, tmp_heat1dnt_00040= [' maximal deviation of FPI at timestep ', num2str(i), ' is ', num2str(checktol), ' K  (', num2str(iter), ')'];
               disp(tmp_heat1dnt_00040); clear tmp_heat1dnt_00040 ;
            end
            if checktol<= tol, break; end
            if g_checktol/g_checktol_old <= 0.0001
            if iter>= maxiter, break; end
            else
             g_tmp_heat1dnt_00039= g_Tnew- g_Titer;
             tmp_heat1dnt_00039= Tnew- Titer;
             checktol= norm(tmp_heat1dnt_00039, inf); 
             g_checktol=max(0.0001,norm(g_tmp_heat1dnt_00039, inf); 
         end
         g_Titer= g_Tnew;
         Titer= Tnew; 
         %    end NONLINEAR ITERATION
      end
      g_Tlast= g_Tnew;
      Tlast= Tnew; 
      % end TIME STEPPING
      if out~= 0, g_T(: , i+ 1)= g_Tnew;
         T(: , i+ 1)= Tnew; end
      % end TIME STEPPING
   end
   
   if out== 0; 
      g_T= g_Tnew;
      T= Tnew; 
   else 
      T(: , 1)= T0; 
      g_T(: , 1)= zeros(size(T(: , 1)));
   end
   %
   % if nargout > 4 , k_eff=keff'; end
   % if nargout > 5 , rc_eff=rceff'; end
   % if nargout > 6 , ipor=(pori./por)'; end
   % if nargout > 7 , lheat=(por.*rhof.*Lh.*dgf)'; end
   % if nargout > 8 , rci=(rhoi.*cpi)'; end
   
   
   
   
   
   
   
   
