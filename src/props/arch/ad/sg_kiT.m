%
%                             DISCLAIMER
%
%
% This file was generated by:
% ADiMat version 0.5.2 (*** DEBUG ***, beta, lcse, gcse(ß), fwdmd, 2fwdmd, opt_ls, constfold, narg, vararg(ß), Jun 27 2008) arch: i686-pc-linux-gnu
% compiled Jun 27 2008 with gcc 4.1.2 20070925 (Red Hat 4.1.2-33).
% Copyright 2001- 2007 Andre Vehreschild, Institute for
% Scientific Computing, Aachen University, D-52056 Aachen, Germany.
% http://www.sc.rwth-aachen.de/vehreschild/adimat/
% This file was augmented on Thu Oct 23 16:15:55 2008
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOLOOPSAVING -- Do not insert ls_* functions to encapsulate the loops over
%		 directional derivatives.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% VISITFWDMD  -- Use the visitor to generate the differentiated code.
% GRADFUNCPREFIX='sg_'

function [g_ki, ki]= sg_kiT(g_T, T)
   % calculate ice thermal conductivity [mW/(m*K)]
   % regression on published dataif nargin <2, nonlinear='yes'; end;
   % Identifier 'size' is ignored during differentiation.
   tmp_size_00002= size(T);
   g_tmp_size_00002= zeros(size(tmp_size_00002));
   g_ki= 0.00001* zeros(tmp_size_00002);
   ki= 0.00001* ones(tmp_size_00002); 
   clear tmp_size_00002 g_tmp_size_00002 ;
   tmp_kiT_00000= T< 0;
   g_tmp_kiT_00000= zeros(size(tmp_kiT_00000));
   g_ki(T< 0)= -0.0112* g_T(tmp_kiT_00000);
   ki(T< 0)= 2.164- 0.0112* T(tmp_kiT_00000); 
   clear tmp_kiT_00000 g_tmp_kiT_00000 ;
