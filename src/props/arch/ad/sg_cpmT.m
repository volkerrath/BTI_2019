%
%                             DISCLAIMER
%
%
% This file was generated by:
% ADiMat Version 0.4-r9 (beta, lcse, gcse(ß), fwdmd, 2fwdmd, opt_ls, constfold, narg, vararg(ß), Jun 21 2006) arch: i686-pc-linux-gnu
% compiled Jun 21 2006 with gcc 3.4.4 20050721 (Red Hat 3.4.4-2).
% Copyright 2001- 2004 Andre Vehreschild, Institute for
% Scientific Computing, Aachen University, D-52056 Aachen, Germany.
% http://www.sc.rwth-aachen.de/vehreschild/adimat/
% This file was augmented on Thu Apr 10 14:40:11 2008
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% FUNCMODE -- Inputfile is a function (This flag can not be set explicitly).

function [g_cpmT, cpmT]= g_cpmT(g_cp, cp, g_T, T, T0, T1, A, B, C)
   % calculates heat capacity of rocks as function of temperature
   % based on the formula given in Hermann(1999)
   % T           =  temperature in C  acording to flag unit
   % A           =  regression coeff., 0.7         < A < 0.8
   % B           =  regression coeff., 0.0014      < B < 0.0022
   % C           =  regression coeff., -0.00000334 < C < 0.0000016
   % vr april 25, 2004
   
   narginmapper_00004= [0, 1, 0, 2, 3, 4, 5, 6, 7];
   if narginmapper_00004(nargin)< 5, A= 0.75e3; B= 0.0018e3; C= -0.00000245e3; end
   if narginmapper_00004(nargin)< 3, T0= 20.; T1= 800; end
   
   [n1, n2]= size(cp); if n1== 1, g_tmp_cpmT_00004= g_cp' ;
      tmp_cpmT_00004= cp' ; % Update detected: cp= some_expression(cp,...)
      g_cp= g_tmp_cpmT_00004;
      cp= tmp_cpmT_00004;
   end
   [n1, n2]= size(T); if n1== 1, g_tmp_cpmT_00005= g_T' ;
      tmp_cpmT_00005= T' ; % Update detected: T= some_expression(T,...)
      g_T= g_tmp_cpmT_00005;
      T= tmp_cpmT_00005;
   end
   cp0= A+ B* T0+ C* T0^ 2; f= cp./ cp0; 
   g_tmp_cpmT_00001= B* g_T;
   tmp_cpmT_00001= B* T;
   g_tmp_cpmT_00002= C* g_T;
   tmp_cpmT_00002= C* T;
   g_tmp_cpmT_00003= ls_prod(g_tmp_cpmT_00002, tmp_cpmT_00002, g_T, T);
   tmp_cpmT_00003= tmp_cpmT_00002.* T;
   g_cp= g_tmp_cpmT_00001+ g_tmp_cpmT_00003;
   cp= A+ tmp_cpmT_00001+ tmp_cpmT_00003; 
   
   clear tmp_cpmT_00001 tmp_cpmT_00002 tmp_cpmT_00003 g_tmp_cpmT_00001 g_tmp_cpmT_00002 g_tmp_cpmT_00003 ;
   cp1= A+ B* T1+ C* T1^ 2; ilimit= find(T>= T1); cp(ilimit)= cp1; 
   g_cp(ilimit)= zeros(size(cp(ilimit)));
   g_cpmT= g_cp;
   cpmT= cp; 
