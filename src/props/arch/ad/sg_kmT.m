%
%                             DISCLAIMER
%
%
% This file was generated by:
% ADiMat Version 0.4-r9 (beta, lcse, gcse(ß), fwdmd, 2fwdmd, opt_ls, constfold, narg, vararg(ß), Jun 21 2006) arch: i686-pc-linux-gnu
% compiled Jun 21 2006 with gcc 3.4.4 20050721 (Red Hat 3.4.4-2).
% Copyright 2001- 2004 Andre Vehreschild, Institute for
% Scientific Computing, Aachen University, D-52056 Aachen, Germany.
% http://www.sc.rwth-aachen.de/vehreschild/adimat/
% This file was augmented on Thu Apr 10 14:40:11 2008
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% FUNCMODE -- Inputfile is a function (This flag can not be set explicitly).

function [g_kmT, kmT]= g_kmT(lamb0, g_T, T, A, B, T0, T1)
   % calculates thermal conductivity as function of temperature
   % 0ed on the formula given in Clauser & Huenges
   % (1995, AGU Reference shelf).
   % T           =  temperature in C  acording to flag unit
   % A,B         =  coefficients for formula
   %                (default: A=0.7,B=770, see reference)
   % T0          =  base temperature for caluculation of 
   %                relative conductivities (default: T0=20 C)
   % v. r. nov. 2, 2002
   narginmapper_00005= [1, 0, 2, 3, 4, 5, 6];
   if narginmapper_00005(nargin)< 5, T0= 20.; T1= 800; end
   if narginmapper_00005(nargin)< 3, A= 0.7; B= 770; end
   
   [n1, n2]= size(T); if n1== 1, g_tmp_kmT_00001= g_T' ;
      tmp_kmT_00001= T' ; % Update detected: T= some_expression(T,...)
      g_T= g_tmp_kmT_00001;
      T= tmp_kmT_00001;
   end
   
   if A> 0, 
      labas= A+ B/ (350+ T0); 
      lalim= A+ B/ (350+ T1); 
      
      g_tmp_kmT_00000= (-B.* (g_T))./ (350+ T).^ 2;
      tmp_kmT_00000= B./ (350+ T);
      g_lambda= g_tmp_kmT_00000;
      lambda= A+ tmp_kmT_00000; 
      clear tmp_kmT_00000 g_tmp_kmT_00000 ;
      ilimit= find(T>= T1); 
      lambda(ilimit)= lalim(ilimit); 
      
      g_lambda(ilimit)= zeros(size(lambda(ilimit)));
      f= lamb0./ labas; g_kmT= f.* g_lambda;
      kmT= f.* lambda; 
   else 
      kmT= lamb0; 
      g_kmT= zeros(size(kmT));
   end
